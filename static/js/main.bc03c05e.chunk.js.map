{"version":3,"sources":["components/GameOfLife.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["GameOfLifeFPS","props","useState","frames","htmlFPS","useRef","renderFPS","now","lastFrameTimeStamp","fps","push","length","shift","min","Infinity","max","sum","i","Math","getFPSStatistic","framesCount","currentFps","mean","textContent","round","trim","setFPS","useEffect","current","performance","className","ref","PlayPauseButton","onClick","e","currentTarget","GameOfLife","UNIVERSE_SIZE","htmlCanvas","wasm","setWasm","universe","setUniverse","memory","setMemory","setLastFrameTimeStamp","animationId","setAnimationId","asyncLoadWasm","a","Universe","new","wasmBG","console","error","message","drawCells","canvas","ctx","getContext","cellsPtr","cells","width","height","universeWidth","universeHeight","Uint8Array","buffer","beginPath","fillCells","cellState","color","fillStyle","Array","from","keys","forEach","ind","index","border","x","y","trunc","col","row","fillRect","fillCell","Cell","Alive","Dead","stroke","play","strokeStyle","drawLine","x0","y0","x1","y1","moveTo","lineTo","drawVerticalLine","drawHorizontalLine","j","drawGrid","_renderLoop","tick","requestAnimationFrame","renderLoop","canvasOnClick","event","boundingRect","getBoundingClientRect","scaleX","scaleY","canvasLeft","clientX","left","canvasTop","clientY","top","floor","toggle_cell","setCanvas","addEventListener","cancelAnimationFrame","undefined","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.bc03c05e.chunk.js","sourcesContent":["import { Universe, Cell } from 'gameOfLife';\r\nimport React, { useEffect, useRef, useState } from 'react';\r\nimport './GameOfLife.css';\r\n\r\ntype WasmGameOfLife = typeof import('gameOfLife');\r\ninterface GameOfLifeFPSProps{\r\n  lastFrameTimeStamp: number\r\n}\r\ninterface GameOfLifePlayPauseButtonProps{\r\n  onClick: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void\r\n}\r\n\r\n\r\nconst GameOfLifeFPS: React.FC<GameOfLifeFPSProps> = (props) => {  \r\n  const [frames] = useState<number[]>([]);\r\n  const htmlFPS = useRef<HTMLDivElement>(null); // document.getElementById(\"fps\");\r\n  const setFPS = (htmlFPS: HTMLDivElement, framesCount: number, currentFps: number, sum: number, min: number, max: number) =>{\r\n    if (htmlFPS) {\r\n      let mean = sum / framesCount;\r\n      htmlFPS.textContent = `\r\n      Frames per Second:\r\n               latest = ${Math.round(currentFps)}\r\n      avg of last 100 = ${Math.round(mean)}\r\n      min of last 100 = ${Math.round(min)}\r\n      max of last 100 = ${Math.round(max)}\r\n      `.trim();\r\n    }\r\n  }\r\n  const getFPSStatistic = (frames: number[]) => {\r\n    let min = Infinity;\r\n    let max = -Infinity;\r\n    let sum = 0;\r\n    for (let i = 0; i < frames.length; i++) {\r\n      sum += frames[i];\r\n      min = Math.min(frames[i], min);\r\n      max = Math.max(frames[i], max);\r\n    }\r\n    return {min, max, sum};\r\n  }\r\n  const renderFPS = (htmlFPS: HTMLDivElement, frames: number[], now: number, lastFrameTimeStamp: number) =>{\r\n    // Convert the delta time since the last frame render into a measure\r\n    // of frames per second.\r\n    const delta = now - lastFrameTimeStamp;\r\n    const fps = 1 / delta * 1000;\r\n    // Save only the latest 100 timings.\r\n    frames.push(fps);\r\n    if (frames.length > 100) {\r\n      frames.shift();\r\n    }\r\n    // Find the max, min, and mean of our 100 latest timings.\r\n    let {min, max, sum} = getFPSStatistic(frames);\r\n    setFPS(htmlFPS, frames.length, fps, sum, min, max);\r\n  }\r\n  useEffect(() => {\r\n    if (frames.length === 0 || frames[frames.length - 1] !== props.lastFrameTimeStamp){\r\n      renderFPS(htmlFPS.current as HTMLDivElement, frames, performance.now(), props.lastFrameTimeStamp);\r\n    }\r\n  });\r\n  return  (<div className=\"fps\" ref={htmlFPS}></div>);\r\n}\r\nconst PlayPauseButton: React.FC<GameOfLifePlayPauseButtonProps> = (props) => {\r\n  const onClick = (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) =>{\r\n    props.onClick(e);\r\n    e.currentTarget.textContent = \"▶\" === e.currentTarget.textContent ? \"⏸\" : \"▶\";\r\n  }\r\n  return (<button onClick={onClick}>⏸</button>);\r\n}\r\n\r\nconst GameOfLife: React.FC = () => {\r\n  const UNIVERSE_SIZE = {width: 50, height: 50};\r\n  const CELL_SIZE = 10; // px\r\n  const GRID_COLOR = \"#CCCCCC\";\r\n  const DEAD_COLOR = \"#FFFFFF\";\r\n  const ALIVE_COLOR = \"#000000\";\r\n  \r\n  const htmlCanvas = useRef<HTMLCanvasElement>(null);\r\n  const [wasm, setWasm] =  useState<WasmGameOfLife>();\r\n  const [universe, setUniverse] =  useState<Universe>();\r\n  const [memory, setMemory] =  useState<WebAssembly.Memory>();\r\n  const [lastFrameTimeStamp, setLastFrameTimeStamp] = useState<number>(performance.now());\r\n  const [animationId, setAnimationId] = useState<number | undefined>(performance.now());\r\n\r\n  const asyncLoadWasm = async () => {\r\n    try {\r\n      const wasm = await import('gameOfLife');\r\n      setWasm(wasm);\r\n      setUniverse(wasm.Universe.new(UNIVERSE_SIZE.width, UNIVERSE_SIZE.height));\r\n      const wasmBG = await import('gameOfLife/gameOfLife_bg.wasm');\r\n      setMemory(wasmBG.memory);\r\n    } catch (err) {\r\n      console.error(`Unexpected error in loadWasm. [Message: ${err.message}]`);\r\n    }\r\n  }\r\n  const setCanvas = (canvas: HTMLCanvasElement, universe: Universe) => {\r\n    canvas.height = (CELL_SIZE + 1) * universe.height() + 1;\r\n    canvas.width = (CELL_SIZE + 1) * universe.width() + 1;\r\n  }\r\n  const drawGrid = (canvas: HTMLCanvasElement) => {\r\n    let ctx = canvas.getContext('2d');\r\n    if (!ctx) return;\r\n    ctx.beginPath();\r\n    ctx.strokeStyle = GRID_COLOR;\r\n  \r\n    const drawLine = (ctx: CanvasRenderingContext2D, x0: number, y0: number, x1: number, y1: number) => {\r\n      ctx.moveTo(x0,y0);\r\n      ctx.lineTo(x1,y1);\r\n    }\r\n    const drawVerticalLine = (ctx: CanvasRenderingContext2D, x: number, y0: number, y1: number) => drawLine(ctx, x, y0, x, y1);\r\n    for (let i = 0; i <= canvas.width; i++) {\r\n      const x = i * (CELL_SIZE + 1) + 1, \r\n        y0 = 0,\r\n        y1 = (CELL_SIZE + 1) * canvas.height + 1;\r\n      drawVerticalLine(ctx, x, y0, y1);\r\n    }\r\n  \r\n    const drawHorizontalLine = (ctx: CanvasRenderingContext2D, y: number, x0: number, x1: number) => drawLine(ctx, x0, y, x1, y);\r\n    for (let j = 0; j <= canvas.height; j++) {\r\n      const y = j * (CELL_SIZE + 1) + 1, \r\n        x0 = 0,\r\n        x1 = (CELL_SIZE + 1) * canvas.width + 1;\r\n      drawHorizontalLine(ctx, y, x0, x1);\r\n    }\r\n  \r\n    ctx.stroke();\r\n  };\r\n  const drawCells = (canvas: HTMLCanvasElement, universe: Universe, wasm: WasmGameOfLife, memory: WebAssembly.Memory) => {\r\n    let ctx = canvas.getContext('2d');\r\n    if (!ctx || !universe || !memory) return;\r\n    const cellsPtr = universe.cells();\r\n    const [universeWidth, universeHeight] = [universe.width(), universe.height()];\r\n    const cells = new Uint8Array(memory.buffer, cellsPtr, universeWidth * universeHeight);\r\n    ctx.beginPath();\r\n\r\n    const fillCell = (ctx: CanvasRenderingContext2D, row: number, col: number) => {\r\n      ctx.fillRect(\r\n        col * (CELL_SIZE + 1) + 1,\r\n        row * (CELL_SIZE + 1) + 1,\r\n        CELL_SIZE,\r\n        CELL_SIZE\r\n      );\r\n    }\r\n    const getCoordinates = (index: number, border: {x: number, y: number}) => [Math.trunc(index % border.x), Math.trunc(index / border.y)];\r\n    const fillCells = (ctx: CanvasRenderingContext2D, cells: Uint8Array, cellState: Cell, color: string, universe: Universe) =>{ \r\n      const [universeWidth, universeHeight] = [universe.width(), universe.height()];\r\n      ctx.fillStyle = color;\r\n      Array.from(Array(universeHeight * universeWidth).keys()).forEach(ind => {\r\n        if (cells[ind] === cellState){\r\n          let [col, row] = getCoordinates(ind, {x: universeWidth, y: universeHeight});//[Math.trunc(ind % universeWidth), Math.trunc(ind / universeHeight)];\r\n          fillCell(ctx, row, col);\r\n        }\r\n      });\r\n    }\r\n\r\n    fillCells(ctx, cells, wasm.Cell.Alive, ALIVE_COLOR, universe);\r\n    fillCells(ctx, cells, wasm.Cell.Dead, DEAD_COLOR, universe);\r\n\r\n    ctx.stroke();\r\n  }\r\n  const renderLoop = (canvas: HTMLCanvasElement, universe: Universe, wasm: WasmGameOfLife, memory: WebAssembly.Memory) => { \r\n    if (!universe) return;\r\n    drawGrid(canvas);\r\n    const _renderLoop = () =>{\r\n      setLastFrameTimeStamp(performance.now());//!!\r\n      drawCells(canvas, universe, wasm, memory);\r\n      universe.tick();\r\n      setAnimationId(requestAnimationFrame(_renderLoop))\r\n      //animationId = requestAnimationFrame(_renderLoop); \r\n    } \r\n    _renderLoop();\r\n  };\r\n  const play = (canvas: HTMLCanvasElement, universe: Universe, wasm: WasmGameOfLife, memory: WebAssembly.Memory) => {\r\n    renderLoop(canvas, universe, wasm, memory);\r\n  };\r\n  const pause = () => {\r\n    if (!animationId) return; //lol ts\r\n    cancelAnimationFrame(animationId);\r\n    setAnimationId(undefined);\r\n  };\r\n  const isPaused = () => !animationId;\r\n  \r\n  const canvasOnClick = (event: MouseEvent) => {\r\n    let canvas = htmlCanvas.current as HTMLCanvasElement;\r\n    const boundingRect = canvas.getBoundingClientRect();\r\n\r\n    const scaleX = canvas.width / boundingRect.width;\r\n    const scaleY = canvas.height / boundingRect.height;\r\n\r\n    const canvasLeft = (event.clientX - boundingRect.left) * scaleX;\r\n    const canvasTop = (event.clientY - boundingRect.top) * scaleY;\r\n\r\n    const row = Math.min(Math.floor(canvasTop / (CELL_SIZE + 1)), canvas.height - 1);\r\n    const col = Math.min(Math.floor(canvasLeft / (CELL_SIZE + 1)), canvas.width - 1);\r\n\r\n    if (!universe) return;\r\n    universe.toggle_cell(row, col);\r\n    drawCells(canvas, universe, wasm as WasmGameOfLife, memory as WebAssembly.Memory);\r\n  };\r\n\r\n  const playPauseButtonOnClick = () => {\r\n    if (isPaused()) {\r\n      let canvas = htmlCanvas.current as HTMLCanvasElement;\r\n      play(canvas, universe as Universe, wasm as WasmGameOfLife, memory as WebAssembly.Memory); //!!\r\n    } else {\r\n      pause();\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n     asyncLoadWasm();\r\n  }, []);\r\n  useEffect(() => {\r\n    if (universe && memory && wasm){\r\n      let canvas = htmlCanvas.current as HTMLCanvasElement;\r\n      if (canvas)\r\n      {\r\n        setCanvas(canvas, universe);\r\n        play(canvas, universe, wasm, memory);\r\n        canvas.addEventListener('click', canvasOnClick);\r\n      }\r\n    }\r\n\r\n  }, [universe, memory, wasm])\r\n  return (\r\n    <div className=\"GameOfLife\">\r\n      <PlayPauseButton onClick={playPauseButtonOnClick}/>  \r\n      <GameOfLifeFPS lastFrameTimeStamp={lastFrameTimeStamp}/>\r\n      <canvas ref={htmlCanvas} />\r\n    </div>\r\n  );\r\n}\r\n\r\n\r\nexport default GameOfLife;\r\n","import React from 'react';\r\nimport GameOfLife from './components/GameOfLife';\r\nimport './App.css';\r\n\r\nconst App: React.FC = () => {\r\n  return (\r\n    <GameOfLife/>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}